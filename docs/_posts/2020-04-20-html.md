---
title: "From Deployment to Defense: How to Set Up Microsoft Defender External Attack Surface Management (MDEASM) using Terraform and Azure DevOps"
date: 2024-09-11
layout: post
---

As organizations expand their digital footprint, managing and securing external assets becomes a critical challenge. Microsoft Defender External Attack Surface Management (MDEASM) helps to address this by providing comprehensive visibility into your external assets and potential vulnerabilities. By continuously discovering, tracking, and analyzing the attack surface, MDEASM empowers organizations to proactively mitigate security risks.

In this blog post, I will walk you through the steps to deploy MDEASM using Azure DevOps pipelines, automating the infrastructure provisioning via Terraform. After setting up MDEASM, we'll configure Discovery Groups using the MDEASM API, also integrated into a DevOps pipeline. This enables a fully automated and repeatable deployment of your external attack surface management, ensuring that your organization can efficiently scale its security operations while minimizing manual intervention.

By the end of this guide, you'll have:

1. An understanding of how to automate the deployment of MDEASM with Terraform in Azure DevOps.
2. A fully automated process for configuring Discovery Groups via the MDEASM API, integrated into your pipeline.

All code referenced from here on can be found in my [mdeasm-devops repo](https://github.com/gwilkinson01/mdeasm-devops/).

## Deployment

MDEASM is not yet supported through Azure Resource Manager (ARM). Nevertheless, you can still deploy using an ARM template if you know the resource provider. For this tutorial, I will reference `Microsoft.Easm/workspaces@2023-04-01-preview` as the resource provider. In case that changes in the future, you can check for the most up to date version [here](https://learn.microsoft.com/en-us/rest/api/defenderforeasm/controlplanepreview/workspaces?view=rest-defenderforeasm-controlplanepreview-2023-04-01-preview).

With the resource provider we can generate our ARM Template:

```json
{
  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
  "contentVersion": "1.0.0.0",
  "metadata": {
    "_generator": {
      "name": "bicep",
      "version": "0.9.1.41621",
      "templateHash": "10012041125269374402"
    }
  },
  "parameters": {
    "name": {
      "type": "string",
      "defaultValue": "mdeasm1"
    },
    "region": {
      "type": "string",
      "defaultValue": "westeurope"
    }
  },
  "resources": [
    {
      "type": "Microsoft.Easm/workspaces",
      "apiVersion": "2023-04-01-preview",
      "name": "[parameters('name')]",
      "location": "[parameters('region')]",
      "properties": {}
    }
  ]
}
```

Note: you could use Bicep to generate this template. The template would look something like this:

```bicep
param name string = 'easm-work'
param region string = 'eastus'
resource Easm 'Microsoft.Easm/workspaces@2023-04-01-preview' = {
name: name
location: region
properties: {}
}
```

Next you need to create terraform files. 

`main.tf` is where you declare the resources you want to be created. This is where you reference the ARM template just made. 

```hcl
terraform {
  backend "http" {}
}

resource "azurerm_resource_group" "rg" {
    name = var.resource_group_name
    location = var.resource_group_location
}

resource "azurerm_template_deployment" "easm_deployment" {
    name = "mdeasm2"
    resource_group_name = azurerm_resource_group.rg.name
    deployment_mode = "Incremental"

    template_body = file("${path.module}/easm-deployment.json")

    parameters = {
      name = var.easm_workspace_name
      region = azurerm_resource_group.rg.location
    }

    depends_on = [azurerm_resource_group.rg]
}
```

Important to note here is the use of `${path.module}`. This ensures to point to the current directory. With Terraform you do not reference file paths like `myrepo/subdir/` as it throws up errors.


















